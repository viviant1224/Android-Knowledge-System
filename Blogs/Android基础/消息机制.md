# 消息机制

## 简介
消息处理机制本质是一个线程开启循环模式持续监听并依次处理其他线程给它发的消息。

简单的说：一个线程开启一个无限循环模式，不断遍历自己的消息列表，如果有消息就挨个拿出来做处理，如果列表没消息，自己就堵塞(相当于 wait，让出 CPU 资源给其他线程)，其他线程如果想让该线程做什么事，就往该线程的消息队列插入消息，该线程会不断从队列里拿出消息做处理。

## Handler 的作用
Handler 能够发送和处理 Message 和 Runnable，每个 Handler 对象对应一个 Thread 和 Thread 的消息队列。每当创建一个 Handler时，它就和所在线程的消息队列绑定在一起，然后就可以传递 Message 和 Runnable 到消息队列中，执行消息后就从消息队列中退出。

Handler 有以下两个主要用途：

执行定时任务：将未来某个时间点将要执行的 Message 或 Runnable 加入到消息队列；  
线程间的通信：在子线程把需要在另一个线程执行的操作加入到消息队列中去。

## Handler消息机制
![image](https://user-images.githubusercontent.com/7577770/111966801-4d832c80-8b32-11eb-9133-fee1ce09f70e.png)
![image](https://user-images.githubusercontent.com/7577770/111966838-5a078500-8b32-11eb-9670-073bf3f256fa.png)   

从 Handler 消息机制的架构图中可以看到：  

* Looper 有一个 MessageQueue 消息队列；  
* MessageQueue 有一组待处理的 Message；  
* Message 中有一个用于处理消息的 Handler；  
* Handler 中有 Looper 和 MessageQueue  

![image](https://user-images.githubusercontent.com/7577770/111967266-cb473800-8b32-11eb-8106-40fba482d404.png)

## Looper
默认情况下，线程没有与之关联的消息循环；当一个线程运行到某处，准备创建一个消息循环，必须在将要运行循环的线程中先调用 Looper.prepare() 做一些准备工作(即：创建一个 Looper 对象，并把它设置进线程的本地存储区里)，然后继续调用 Looper.loop() 建立起消息处理循环，开始让它处理消息，直到循环停止。
### prepare()
prepare()方法用于线程创建消息循环前做一些准备工作，创建一个 Looper 对象，并把它设置进线程的本地存储区里。对于无参的情况，默认调用 prepare(true)，表示的是当前 Looper 允许退出，而对于 false 的情况则表示当前 Looper 不允许退出。prepare() 方法的源码如下：
 ```
public static void prepare() {
  prepare(true);
} 

private static void prepare(boolean quitAllowed) {
  // 每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常
  if (sThreadLocal.get() != null) {
    throw new RuntimeException("Only one Looper may be created per thread");
  }
  // 创建Looper对象，并保存到当前线程的TLS区域
  sThreadLocal.set(new Looper(quitAllowed));
}
 ```
 这里的 sThreadLocal 是 ThreadLocal 类型
 Looper.prepare() 在每个线程只允许执行一次，该方法会创建 Looper 对象，Looper 的构造方法中会创建一个 MessageQueue 对象，再将 Looper 对象保存到当前线程本地存储区。Looper 的构造方法如下：
```
private Looper(boolean quitAllowed) {
  // 创建MessageQueue对象
  mQueue = new MessageQueue(quitAllowed);
  // 记录当前线程 
  mThread = Thread.currentThread(); 
}

```
与 prepare() 方法功能相近的，还有一个 prepareMainLooper() 方法，该方法主要在 android.app.ActivityThread 类中使用，它是为主线程创建一个 Looper，在主线程创建 Looper 对象中，就设置了不允许退出消息循环。prepareMainLooper() 方法的源码如下：
```
public static void prepareMainLooper() {
  // 设置不允许退出的
  Looper prepare(false);
  synchronized (Looper.class) {
    // 将当前的Looper保存为主Looper，每个线程只允许执行一次
    if (sMainLooper != null) {
      throw new IllegalStateException("The main Looper has already been prepared."); 
    }
    sMainLooper = myLooper();
  }
}

```

### myLooper()
myLooper()方法用于获取 TLS 存储的 Looper 对象。如果调用线程未与 Looper 关联(没有调用过 prepare() 方法)则返回 null。myLooper() 方法的源码如下：

```
public static @Nullable Looper myLooper() {
    return sThreadLocal.get();
}
```
另外，与 myLooper() 方法功能相近的，还有一个 getMainLooper() 方法，该方法用于获取主线程的 Looper 对象。getMainLooper() 方法的源码如下：

```
public static Looper getMainLooper() {
    synchronized (Looper.class) {
        return sMainLooper;
    }
}
```
### loop()
loop()方法用于开启消息循环，让 Looper 开始工作，从消息队列里取出消息并处理。loop() 方法的源码如下：

```
public static void loop() {
    // 获取TLS存储的Looper对象
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    // 获取Looper对象中的消息队列
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    // 确保在权限检查时基于本地进程，而不是调用进程
    final long ident = Binder.clearCallingIdentity();

    // 进入loop的主循环方法
    for (; ; ) {
        // 取出消息队列中的下一条消息(可能会阻塞)
        Message msg = queue.next(); // might block
        // 没有消息，则退出循环
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // 默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " +
                    msg.callback + ": " + msg.what);
        }


        // 用于分发Message
        msg.target.dispatchMessage(msg);
        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;

        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }

        // 恢复调用者信息
        final long newIdent = Binder.clearCallingIdentity();
        msg.recycleUnchecked();
    }
}
```
loop() 方法进入循环模式，不断重复下面的操作，直到没有消息时退出循环：

读取 MessageQueue 的下一条 Message；  
把 Message 分发给相应的 target；  
再把分发后的 Message 回收到消息池，以便重复利用。  
这是这个消息处理的核心部分。另外，上面代码中可以看到有 logging 方法，这是用于 debug 的，默认情况下 logging == null，通过设置 setMessageLogging() 用来开启 debug 工作。

***注意：写在 Looper.loop() 之后的代码不会被执行，这个函数内部是一个循环，当调用 mHandler.getLooper().quit() 后，loop 才会中止，其后的代码才能得以运行。***

### quit()
quit()方法用于退出消息循环，让 Looper 停止工作。quit() 方法的源码如下：

```
public void quit() {
    // 移除消息队列中的消息
    mQueue.quit(false);
}

public void quitSafely() {
    // 安全地移除消息队列中的消息
    mQueue.quit(true);
}
```
quit() 方法的实现最终调用的是 MessageQueue.quit() 方法，传入 true 表示只移除尚未触发的所有消息，对于正在触发的消息并不移除；传入 flase 表示移除所有的消息。

## Message



## ThreadLocal

ThreadLocal 表示线程本地存储区(Thread Local Storage，简称为 TLS)，每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域。
