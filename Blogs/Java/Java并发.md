# Java并发
## 线程
### 多线程
**线程创建的三种方式**
* 继承Thread类创建线程类
* 通过Runnable接口创建线程类
* 通过Callable和Future创建线程  

**创建线程的三种方式的对比**  
采用实现Runnable、Callable接口的方式创见多线程时，优势是：
线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。
在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
劣势是：
编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。
使用继承Thread类的方式创建多线程时优势是：
编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。
劣势是：
线程类已经继承了Thread类，所以不能再继承其他父类。

### 线程池

**什么是线程池**  
线程池的基本思想是一种对象池，在程序启动时就开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。

**使用线程池的好处**  
* 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
* 运用线程池能有效的控制线程最大并发数，可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。
* 对线程进行一些简单的管理，比如：延时执行、定时循环执行的策略等，运用线程池都能进行很好的实现  

**ThreadPoolExecutor**

**三种阻塞队列**

**四种拒绝策略**

**创建一个线程池需要输入几个参数**  
* corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。  
* maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。  
* runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。  
* ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。  
* RejectedExecutionHandler（拒绝策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。  
* keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。  
* TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。   

**线程池的分类及特点**  
* CachedThreadPool()：可缓存线程池。线程数无限制，有空闲线程则复用空闲线程，若无空闲线程则新建线程 一定程序减少频繁创建/销毁线程，减少系统开销  
* FixedThreadPool()：定长线程池。可控制线程最大并发数（同时执行的线程数）超出的线程会在队列中等待  
* ScheduledThreadPool()：定时线程池。支持定时及周期性任务执行。  
* SingleThreadExecutor()：单线程化的线程池。有且仅有一个工作线程执行任务所有任务按照指定顺序执行，即遵循队列的入队出队规则   
 
**线程池主要方法**  
向线程池提交任务:我们可以通过execute()或submit()两个方法向线程池提交任务，不过它们有所不同
execute()方法没有返回值，所以无法判断任务知否被线程池执行成功
submit()方法返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值

线程池的关闭
我们可以通过shutdown()或shutdownNow()方法来关闭线程池，不过它们也有所不同
shutdown的原理是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。
shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。

**线程池工作原理**  

**线程池的五种状态**

**Q&A**

## 锁
[Java锁](https://tech.meituan.com/2018/11/15/java-lock.html) 


悲观锁：synchronized Lock
乐观锁：AtomicInteger----->CAS   Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步

***volatile*** 
1、可见性实现：  
* 修改volatile变量时会强制将修改后的值刷新的主内存中。

*　修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。   
2、有序性实现：   
为了实现volatile可见性和happen-befor的语义。JVM底层是通过一个叫做“内存屏障”的东西来完成。内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。

3、不能保证原子性

***synchronized***

原子性：原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。前面中，介绍过，这两个字节码指令，在Java中对应的关键字就是synchronized。

通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。

可见性：被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。

有序性：synchronized是无法禁止指令重排和处理器优化的。也就是说，synchronized无法避免上述提到的问题。由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。

***ReentrantLock***

使用 synchronize 来做同步处理时，锁的获取和释放都是隐式的，实现的原理是通过编译后加上不同的机器指令来实现。

而 ReentrantLock 就是一个普通的类，它是基于 AQS(AbstractQueuedSynchronizer)来实现的。AQS 是 Java 并发包里实现锁、同步的一个重要的基础框架。

是一个重入锁：一个线程获得了锁之后仍然可以反复的加锁，不会出现自己阻塞自己的情况。  

ReentrantLock 分为公平锁和非公平锁，可以通过构造方法来指定具体类型





![image](https://user-images.githubusercontent.com/7577770/111297339-7ade5f00-8688-11eb-9e99-d698484fb0ec.png)

## Java内存模型

## 阻塞队列
