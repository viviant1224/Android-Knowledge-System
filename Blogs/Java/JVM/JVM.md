
# JVM

## 内存模型

### 线程/工作内存/主内存 三者的关系
* 每个线程都有一个独立的工作内存，用于存储线程私有的数据
* Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问
* 线程对变量的操作(读取赋值等)必须在工作内存中进行。（线程安全问题的根本原因）  
（1）首先要将变量从主内存拷贝的自己的工作内存空间  
（2）然后对变量进行操作，操作完成后再将变量写回主内存  
（3）不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝  
（4）因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。

### 主内存和工作内存
* 主内存是在运行期间所有变量的存放区域，工作内存是运行期间中某一线程独立私有的内存存放区域
* 线程间无法访问对方的工作内存空间，都是通过主内存交换来实现
* 主内存的变量在工作内存中的值是复制过去的副本，读写完成后刷新主内存，这意味着主内存如果发生了改变，工作内存并无法获得最新的结果
* 多个线程对一个共享变量进行修改时，都是对自己工作内存的副本进行操作，相互不可见。主内存最后得到的结果是不可预知的 
### Java 虚拟机内存管理
![image](https://raw.githubusercontent.com/viviant1224/Android-Knowledge-System/main/images/Java/JVM/jvm1.webp)  
* **程序计数器**
内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成
* **虚拟机栈**
线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。  局部变量表：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。
* **本地方法栈**
区别于 Java 虚拟机栈的是，Java 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。也会有 StackOverflowError 和 OutOfMemoryError 异常。
* **方法区**
属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数
* **堆**
对于绝大多数应用来说，这块区域是 JVM 所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。  OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。




## Java垃圾回收

## Java类加载机制
