# 内存优化

## 内存问题

* 内存抖动：锯齿状、GC导致卡顿
* 内存泄露：可用内存减少，频繁GC
* 内存溢出：OOM、程序异常

## 工具选择

* Memory Profiler
* Memory Analyzer
* LeakCanary

## Java内存分配
* 方法区
* 虚拟机栈
* 本地方法栈
* 堆 对象的分配，GC主要作用的区域、重点
* 程序计数器

## Java内存回收算法
标记-清除算法 ：效率不高，产生大量不连续的碎片  
复制算法：实现简单、运行高效；浪费一般空间，代价大  
标记-整理算法：避免标记-清理导致内存碎片；避免复制算法的空间浪费  
分代收集算法：新生代存活率低：复制；老年代存活率高：标记整理算法  

## Android内存管理机制
* 内存弹性分配，分配值与最大值受具体设备影响
* OOM场景：内存真正不足，可用内存不足

## Dalvik与Art区别
* Dalvik仅固定一种回收算法
* Art回收算法可运行期选择
* Art具备内存整理能力，减少内存空间

## Low Memory Killer
* 进程分类（优先级）
* 回收收益

## 内存抖动
* 定义：内存频繁分配和回收导致内存不稳定
* 表现：频繁GC、内存曲线呈锯齿状
* 危害：导致卡顿、OOM

## 内存抖动频繁导致OOM
* 频繁创建对象，导致内存不足及碎片（不连续）
* 不连续的内存片无法被分配，导致OOM

## 内存抖动解决实战
* 使用Memory Profilder初步排查
* 使用Memory Profiler或CPU Profiler结合代码排查
* 技巧：找循环或者频繁调用的地方

## 内存泄露

* 定义：内存中存在已经没有用的对象
* 表现：内存抖动，可用内存逐渐变少
* 危害：内存不足，GC频繁，OOM

## Bitmap内存模型
* API10之前Bitmap自身在Dalvik Heap中，像素在Native
* API10之后像素也放在Dalvik Heap中，原因是10之前Bitmap回收了，像素没有回收，容易导致NativeOOM
* API26之后像素在Native：Google使用的新技术，当Bitmap回收后，关联的像素点也回收了。

## ARTHook
挂钩，将额外的代码勾住原有方法，修改执行逻辑：运行时插桩

* 无侵入式
* 通用性强
* 兼容问题大，开源方案最好不要带到线上环境

## Epic
