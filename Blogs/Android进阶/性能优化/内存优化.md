# 内存优化

## 内存问题

* 内存抖动：锯齿状、GC导致卡顿
* 内存泄露：可用内存减少，频繁GC
* 内存溢出：OOM、程序异常

## 工具选择

* Memory Profiler
* Memory Analyzer
* LeakCanary

## Java内存分配
* 方法区
* 虚拟机栈
* 本地方法栈
* 堆 对象的分配，GC主要作用的区域、重点
* 程序计数器

## Java内存回收算法
标记-清除算法 ：效率不高，产生大量不连续的碎片  
复制算法：实现简单、运行高效；浪费一般空间，代价大  
标记-整理算法：避免标记-清理导致内存碎片；避免复制算法的空间浪费  
分代收集算法：新生代存活率低：复制；老年代存活率高：标记整理算法  

## Android内存管理机制
* 内存弹性分配，分配值与最大值受具体设备影响
* OOM场景：内存真正不足，可用内存不足

## Dalvik与Art区别
* Dalvik仅固定一种回收算法
* Art回收算法可运行期选择
* Art具备内存整理能力，减少内存空间

## Low Memory Killer
* 进程分类（优先级）
* 回收收益

## 内存抖动
* 定义：内存频繁分配和回收导致内存不稳定
* 表现：频繁GC、内存曲线呈锯齿状
* 危害：导致卡顿、OOM

## 内存抖动频繁导致OOM
* 频繁创建对象，导致内存不足及碎片（不连续）
* 不连续的内存片无法被分配，导致OOM

## 内存抖动解决实战
* 使用Memory Profilder初步排查
* 使用Memory Profiler或CPU Profiler结合代码排查
* 技巧：找循环或者频繁调用的地方

## 内存泄露

* 定义：内存中存在已经没有用的对象
* 表现：内存抖动，可用内存逐渐变少
* 危害：内存不足，GC频繁，OOM

## Bitmap内存模型
* API10之前Bitmap自身在Dalvik Heap中，像素在Native
* API10之后像素也放在Dalvik Heap中，原因是10之前Bitmap回收了，像素没有回收，容易导致NativeOOM
* API26之后像素在Native：Google使用的新技术，当Bitmap回收后，关联的像素点也回收了。

## ARTHook
挂钩，将额外的代码勾住原有方法，修改执行逻辑：运行时插桩

* 无侵入式
* 通用性强
* 兼容问题大，开源方案最好不要带到线上环境

## Epic

## 线上内存监控方案
1、设定场景线上Dump： Debug.dumpHprofData
超过最大内存80% --> 内存Dump --> 回传文件 --> 开发同学分析文件

2、LeakCanary带到线上
* 预设泄露怀疑点
* 发现泄露回传

## LeakCanary原理
* 监控生命周期，onDestroy添加RefWatcher检测
* 二次确认断定发生内存泄露
* 分析泄露，找引用链
* 监控组件+分析组件

## 定制LeakCanary

预设怀疑点 -- > 自动找怀疑点
分析泄露链路慢 -- > 分析Retain size大的对象
分析OOM -- >对象裁剪，不全部加载到内存

## 线上监控完整方案
* 待机内存、重点模块内存、OOM率
* 整体及重点模块GC次数、GC时间
* 增强的LeakCanary自动化内存泄露分析

## 内存优化大方向

内存泄露
内存抖动
Bitmap

## 优化细节

LargeHeap属性
onTrimMemory 做一些事情
优化过的集合：SparseArray
谨慎使用SharedPreference
谨慎使用外部库
业务架构设计合理，数据分页等

## 怎么做内存优化
1、线上看到内存泄露、本机实际用Memory Profiler检测到内存抖动、LeakCanary检测到OOM问题开始分析问题，并且解决问题。
2、针对性优化。用工具
2、提升开发团队效率：输出解决方案以及工具使用文档，团队分享

## 内存优化最大感受
学习了很多工具的使用，能够很快的迅速排查问题
技术优化 --> 结合业务，注重用户体验
多个图片库最好不要共用。
系统级完善的解决方案，----> 带到线上服务器，方便报表实时查看每个版本的数据变更

## 如何检测不合理的地方
技术演进：


解决图片使用不合理的地方：
最开始方法：自定义ImageView覆写onDraw等方法---->发现代码侵入式高，很多开发人员不接受
---> 进化方案： ArtHook 钩住方法，进行自动插桩检测。


## Bitmap优化

### Bitmap像素格式
不同的像素格式下每个像素占用字节大小不同，RGB_565 比 ARGB_8888 节省一半内存。
如果使用图片的地方对图片质量要求不高，可以采用 RGB_565 的像素格式。  
比如说，当我们要使用的是缩略图、模糊图等。   
### 资源文件夹目录
图片放在高分辨率的资源文件夹中，更节省内存。  
但是，如果将小图片放在高分辨率的资源文件夹中，加载时将会被拉伸，出现失真现象。  
所以，在 APK 包体积允许的情况下，同一张图片应该提供尽可能多的分辨率，以便放在相应分辨率的资源文件夹中，尤其要提供高分辨率资源文件夹所需的图片。  

bitmap占用内存 ≈ 像素数据总大小 = 原图宽 × 原图高 × (设备分辨率 / 资源目录分辨率)^2 × 每个像素占用的字节大小 = bitmap.getByteCount()

### 采样压缩
1、如果 inSampleSize 大于1，原图就会被采样压缩以节省内存。  
例如，inSampleSize == 4，则横向和纵向像素各采样 1/4，最终取到的像素数是原像素数的1/16。  
2、inSampleSize 的值必须是2的幂值，如果不是2的幂值就会被向下取值取最近的2的幂值。  


